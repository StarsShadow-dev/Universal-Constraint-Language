// map = fn(In: Type, Out: Type) -> Function {
// 	fn(input: [In], callBack: (In) -> Out) -> [Out] {
// 		...
// 	}
// }
// map(Number, String)([1, 2, 3], fn(input: Number) -> String {
// 	Number.toString(input)
// })



// genericFn = fn(names: [String] function: Function) -> Function {
// 	...
// }
// map = genericFn <| ["In", "Out"] <| fn(input: [In], callBack: (In) -> Out) -> [Out] {
// 	...
// }
// map(Number, String)([1, 2, 3], fn(input: Number) -> String {
// 	Number.toString(input)
// })

// ----------

// genericFn = fn(F: Function) -> Function {
// 	F
// }

// if (false) {
// 	1
// } else {
// 	"2"
// }

// map(Number, String)([1, 2, 3], @in Number.toString(in))

// fib = @n
// 	if n < 2 then
// 		n
// 	else
// 		fib(n - 1) + fib(n - 2)


// genericFn = @names([String]) @function(Function) (...) // -> Function
// map = genericFn ["In", "Out"] (@input([In]) @callBack(\(In) -> Out) (...)) // -> [Out]
// map (Number, String) [1, 2, 3] (@input() Number.toString(input))

// getStuff
// 	|> doStuff
// 	|> doMoreStuff

// cd ~lib.std.math
// Vec2 = struct(x: Numner, y: Number)
// Vec2.new = ...

// Vec2.new = @x(getNumber 1) @y(Number)
// 	&Vec2{
// 		x = x
// 		y = y
// 	}

// Vec2.add = @v1(Vec2) @v2(Vec2)
// 	&Vec2{
// 		x = v1.x + v2.x
// 		y = v1.y + v2.y
// 	}

// // ----------

// cd ~myCode
// add = ~lib.std.math.Vec2.add

// test = @v1(Vec2) @v2(Vec2) @v3(Vec2)
// 	add (add v1 v2) v3

// -----

// a.b = 0
// a.b

b = @y(Number)
	t = 2
	1

a = @x(Number)
	t = 2
	b 1

a 2